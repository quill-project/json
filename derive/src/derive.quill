
mod json

use macro::*

// pub enum Color(
//     Red,
//     Green,
//     Blue,
//     Rgb: RgbColor
// )

// pub struct RgbColor(red: Int, green: Int, blue: Int)

// Color::Red                        => { "type": "Red" }
// Color::Green                      => { "type": "Green" }
// Color::Blue                       => { "type": "Blue" }
// Color::Rgb(RgbColor(255, 127, 0)) => { 
//     "type": "Rgb", 
//     "value": {
//         "red": 255,
//         "green": 127,
//         "blue": 0
//     } 
// }

fun value_from_json(v: String, t: Node) -> String {
    val ts: String = t |> as_string()
    val default: String = "Option::None[" |> concat(ts) |> concat("]")
    match t {
        NamedType(Triplet(_, p, ta)) {
            val tas: String = ta
                |> unwrap_or_else(List::empty)
                |> values()
                |> map(Node::as_string)
                |> join(", ")
            return p |> values() |> join("::")
                |> concat("::from_json_val[")
                |> concat(tas)
                |> concat("](")
                |> concat(v)
                |> concat(")")
        }
        _ {}
    }
    return default
}

fun derive_from_json(n: Option[Node], ctx: Compiler) -> List[Token] {
    val o: mut StringBuilder = StringBuilder::empty()
    mut p: String = ""
    mut ta: String = ""
    mut mref: Bool = false
    match n {
        Some(Node::StructDecl(StructDecl(_, path, type_args, _))) {
            p = path |> values() |> join("::")
            ta = type_args |> values() |> join(", ")
            mref = true
        }
        Some(Node::EnumDecl(EnumDecl(_, path, type_args, _))) {
            p = path |> values() |> join("::")
            ta = type_args |> values() |> join(", ")
            mref = false
        }
        _ { return List::empty() }
    }
    o |> push("pub fun ")
    o |> push(p)
    o |> push("::from_json_val[")
    o |> push(ta)
    o |> push("](j: json::Json) -> std::Option[")
    if mref { o |> push("mut ") }
    o |> push(p)
    o |> push("] { ")
    o |> push("mut o: mut std::Map[std::String, json::Json] ")
    o |> push("= std::Map::empty() ")
    o |> push("match json::Json::get_object(j) { ")
    o |> push("std::Option::Some(m) { o = m }")
    o |> push("std::Option::None { return std::Option::None }")
    o |> push("} ")
    match n {
        Some(Node::StructDecl(StructDecl(_, _, _, members))) {
            for mem_i: members |> indices() {
                val member: Pair[String, Node] = members |> at(mem_i)
                o |> push("match std::Map::get(o, \"")
                o |> push(member.first)
                o |> push("\") { ")
                val mem_v: String = "mem" |> concat(mem_i |> as_string())
                val mem_vj: String = mem_v |> concat("j")
                o |> push("std::Option::Some(")
                o |> push(mem_vj)
                o |> push(") { ")
                o |> push("match ")
                o |> push(value_from_json(mem_vj, member.second))
                o |> push(" { ")
                o |> push("std::Option::Some(")
                o |> push(mem_v)
                o |> push(") { ")
            }
            o |> push("return std::Option::Some(")
            o |> push(p)
            o |> push("[")
            o |> push(ta)
            o |> push("]")
            o |> push("(")
            o |> push(members
                |> indices()
                |> map[Int, String](|i| "mem" |> concat(i |> as_string()))
                |> join(", ")
            )
            o |> push(")) ")
            o |> push("} _ {} } } _ {} } " |> repeat(members |> length()))
        }
        Some(Node::EnumDecl(EnumDecl(_, _, _, members))) {
            o |> push("mut type: std::String = \"\"")
            o |> push("match std::Map::get(o, \"type\") { ")
            o |> push("std::Option::Some(jt) { ")
            o |> push("match json::Json::get_string(jt) { ")
            o |> push("std::Option::Some(t) { type = t }")
            o |> push("std::Option::None { return std::Option::None }")
            o |> push("} } ")
            o |> push("std::Option::None { return std::Option::None } ")
            o |> push("} ")
            o |> push("match type { ")
            for member: members |> values() {
                o |> push("\"")
                o |> push(member.first)
                o |> push("\" { ")
                match member.second {
                    Node::NamedType(Triplet(_, List::of("Unit"), _)) |
                    Node::NamedType(Triplet(_, List::of("std", "Unit"), _)) {
                        o |> push("return std::Option::Some(")
                        o |> push(p)
                        o |> push("::")
                        o |> push(member.first)
                        o |> push(")")
                    }
                    other {
                        o |> push("match std::Map::get(o, \"value\") { ")
                        o |> push("std::Option::Some(jv) { ")
                        o |> push("match ")
                        o |> push(value_from_json("jv", other))
                        o |> push(" { ")
                        o |> push("std::Option::Some(v) { ")
                        o |> push("return std::Option::Some(")
                        o |> push(p)
                        o |> push("::")
                        o |> push(member.first)
                        o |> push("(v))")
                        o |> push("} ")
                        o |> push("_ {} ")
                        o |> push("} ")
                        o |> push("} ")
                        o |> push("_ {} ")
                        o |> push("}")
                    }
                }
                o |> push("} ")
            }
            o |> push("_ {} ")
            o |> push("} ")
        }
        _ { return List::empty() }
    }
    o |> push("return std::Option::None ")
    o |> push("} ")
    o |> push("pub fun ")
    o |> push(p)
    o |> push("::from_json[")
    o |> push(ta)
    o |> push("](t: std::String) -> std::Option[")
    if mref { o |> push("mut ") }
    o |> push(p)
    o |> push("] { ")
    o |> push("match json::Json::parse(t) { ")
    o |> push("std::Result::Ok(j) { return ")
    o |> push(p)
    o |> push("::from_json_val[")
    o |> push(ta)
    o |> push("](j) } ")
    o |> push("_ { return std::Option::None } ")
    o |> push("} ")
    o |> push("} ")
    return o |> as_string()
        |> tokenize(ctx)
        |> expect("hard-coded declaration - should be valid")
}

fun derive_as_json(n: Option[Node], ctx: Compiler) -> List[Token] {
    return List::empty()
}

pub fun derive_json(input: List[Token], ctx: Compiler) -> List[Token] {
    val n: Option[Node] = input |> parse_decl(ctx)
    return input
        |> concat(derive_from_json(n, ctx))
        |> concat(derive_as_json(n, ctx))
}